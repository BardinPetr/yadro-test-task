# Тестовое задание Ядро RTL

## Запуск

Требования:

- Linux
- Verilator
- GTKWave
- библиотека [dawsonjon/fpu](https://github.com/dawsonjon/fpu) (в сабмодулях)

```shell
git clone git@github.com:BardinPetr/yadro-test-task.git
git submodule update --init

make build/addlist_tb  # сборка исходников с verilator
make build/addlist_tb.vcd # запуск симуляции с трассировкой (отчет выводится с пометкой "TEST RESULTS")
make vis_addlist_tb # make build/addlist_tb.vcd + gtkwave
make testgen # генерация тестовых данных для addlist_tb.sv
```

## Описание

Так как стоит задача складывать "больше" количество значений, то стоит предположить, что оно достаточно большое, чтобы его нельзя было бы обработать некоторой последовательной схемой из комбинации блоков сложения. Соответственно будем работать в предположении, что данные скорее всего окажутся в медленной памяти, и на их извлечение еще и придется тратить такты, а извлекать придется пакетами небольшого размера.

Поэтому сначала сделаем следующее: сначала соберем пайплайн в виде дерева для суммирования 2^N чисел. Он соответственно будет на N-1 сумматор и N этапов, это уже некоторое ускорение, но при этом сделать N большим не получится, ибо упремся в площадь.

Чтобы обрабатывать любое возможное количество входных данных, введем для блока следующий процесс. Будем делать 2 параллельных этапа, загрузку данных в временный входной буфер размера 2^N (делает вызывающий модуль), и, соответственно, произведение суммирования данных предыдущего буфера.

Соответственно, мы в пайплайне выполняем последовательно этапы сложения, затем складываем полученное значение с аккумулятором (выходное значение модуля), но перед тем как начать первый этап сложения всегда дожидаемся, что данные точно уже пришли.

Чтобы взаимодействовать с модулем доступа к памяти, предоставляется интерфейс, в котором есть сигнал требования загрузки буфера, и сигнал обратной связи о завершении загрузки.

Определить реальную конфигурацию схемы можно только зная оценку на количество тактов для выполнения сложения 2^N чисел и тактов на загрузку 2^N чисел в буффер. В идеале лучше сделать их равными, тогда все время выполнения пайплайна сложения будет полезным образом использовано.

В итоге на обработку M значений при размере буфера 2^N необходимо M\*max(R, N\*C)/(2^N) где R - такты на загрузку буффера, С - такты на один сумматор.

Получается, что данные так можно обрабатывать не только при большом объеме, но и в потоковом режиме, просто надо обеспечивать наполнение буфера.
